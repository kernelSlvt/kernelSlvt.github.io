<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>why you should learn ocaml | sλrthak</title>
    <!-- math jax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
    ></script>
    <!-- highlight.js -->
    <link rel="stylesheet" href="/themes/gruvbox-dark-hard.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/go.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <link href="/index.css" rel="stylesheet" />
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon" />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Instrument+Serif:ital@0;1&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap");
    </style>
  </head>
  <body>
    <h2><a href="/">sλrthak</a></h2>
    <h1 class="blog-heading">why you should learn ocaml</h1>
    <i>30 Jul, 2025</i>
    <br />
    <br />
    <article><div><p>all of the following ideologies apply to all functional programming languages but here i will be only focusing on ocaml.</p><blockquote>relatablequote.jpg</blockquote><blockquote>Nan-in (南隠), a Japanese master during the Meiji era (1868-1912), received a university professor who came to inquire about Zen. Nan-in served tea. He poured his visitor’s cup full, and then kept on pouring. The professor watched the overflow until he no longer could restrain himself. “It is overfull. No more will go in!” “Like this cup,” Nan-in said, “you are full of your own opinions and speculations. How can I show you Zen unless you first empty your cup?”</blockquote><p>how can learning ocaml will make you a better programmer? because you will:</p><ul><li>experience the freedom of <i>immutability</i>, fuck debugging</li><li>improve at <i>abstraction</i>, fuck bloated code (luke smith giggles)</li><li>learn a better <i>type system</i>, fuck failing tests</li><li>get exposed to some <i>theory and implementation of programming languages</i></li></ul><p>ocaml will change the way you think about programming</p><p>"a language that doesn’t affect the way you think about programming is not worth knowing." - alan j. perlis (first recipient of turing award)</p><p>moreover, ocaml is beautiful. some normies might not agree to this statement but <b>aesthetics do matter</b>. ocaml is elegant, simple and graceful.</p><p>fyi ocaml stands for <i>objective abstract machine language</i>, read <a href="https://cs3110.github.io/textbook/chapters/intro/past.html">more</a> about its history.</p><p><img src="/images/ritsuko.png" alt="ritsuko holding orly"></img></p><p>ocaml is <i>awesome</i> due to:</p><ul><li>immutable programming</li><li>algebraic datatype and pattern matching</li><li>first-class functions</li><li>static type-checking</li><li>auto type inference</li><li>parametric polymorphism</li><li>garbage collection</li><li>modules</li></ul><p>before moving on, you need to understand that <b>languages are tools</b> each language is meant for a specific job</p><ul><li>there is no universally perfect tool</li><li>hence, there is no universally perfect language</li></ul><p>what is a functional language?</p><p>a functional language:</p><ul><li>defines computations as <i>mathematical functions</i></li><li>avoids mutable <i>state</i></li></ul><p><b>state</b>: the info maintained by a computation</p><p>back to basics, what is the difference between a functional programming language (ocaml, haskell, lisp, etc) and an imperative programming language (c++, java, python, etc)?</p><p>the key linguistic abstraction of <i>functional languages</i> is a mathematical function. a function maps an input to an output and for the same input, it always produces the same output. which means that mathematical functions are <i>stateless</i>: they don't maintain any extra info or <i>state</i> that persists between usages of the function.</p><p>functions are <i>first-class</i>: you can use them as input to other functions, and produce functions as output. expressing everything in terms of function enables a uniform and simple programming model that is easier to reason than the procedures and methods found in other langs.</p><p>now, <i>imperative languages</i> involve <i>mutable</i> state that changes throughout execution. commands specify how to compute by destructively changing that state. procedures/methods can have <i>side effects</i> that update state in addition to producing a return value.</p><p>an example of destructive change of state is</p><pre><code>x = x + 1</code></pre><p>now this may seem fine to you, but this will trigger any mathematician.</p><p>buy why is <i>mutability</i> bad?</p><p>the <b>fantasy</b> of mutability: its easy to reason about, computer does operations step by step</p><p>the <b>reality</b> of mutability: indeed, machines are good at complicated manipulation of state, but the thing is that humans are not good at understanding it. the essence of why's that true is that mutability breaks <i>referential transparency</i>: the ability to replace an expression with its value w/o affecting the result of a computation.</p><p>in math, $f(x) = y$, then you can substitute $y$ anywhere you see $f(x)$. in imperative languages, you cannot: $f$ might have side effects, so computing $f(x)$ at time $t$ might result in a different value than at time $t0$.</p><p>it makes it tempting to believe that there's a single state that the machine manipulates and that the computer only does one thing at a time. computer systems go to great lengths in attempting to provide this illusion. but this in fact is just an <i>illusion</i>. in reality, there are many states, spread across threads, cores, processors, and networked systems and it all works concurrently. mutability makes reasoning about distributed state and concurrent execution immensely difficult.</p><p><img src="/images/immutability.jpg" alt="immutability"></img></p><p><i>immutability</i>, however, frees the programmer from these concerns. it provides powerful methods to build correct and concurrent programs.</p><p>in functional langs:</p><p><i>expressions</i> specify <b>what to compute</b></p><ul><li>variables never change value (this may break the very notion of calling them "variables", identifier would be a better replacement, but it's what used throughout)</li><li>functions never have side effects</li></ul><p>ocaml and other functional langs are nowhere near as popular as python, c++ or java. ocaml's real strength lies in language manipulation (compilers, analyzers, verifiers, provers, etc) after all it was evolved from the domain of theorem proving.</p><p>but that doesn't mean that functional langs aren't used in the industry, there are many <a href="https://ocaml.org/learn/companies.html">industry</a> using ocaml and haskell. some of the major ones are:</p><ul><li>facebook: created a language Reason also known as ReasonML i.e syntax extension and toolchain for ocaml. fun fact, it was created by jordan walke who also created react framework at facebook. reason uses many syntax elements from javascript, compiles to native code using ocaml's compiler toolchain, and can compile to javascript using the <i>rescript</i> compiler.</li></ul><p>while reason compiles down to native code via ocaml's toolchain, it specifically differs in the syntax, error messages and editor tooling which provides similar experience to javascript or typescript for devs</p><p>ex:</p><pre><code>type schoolPerson = Teacher | Director | Student(string);
let greeting = person =&gt
  switch (person) {
  | Teacher =&gt "Hey Professor!"
  | Director =&gt "Hello Director."
  | Student("Richard") =&gt "Still here Ricky?"
  | Student(anyOtherName) =&gt "Hey, " ++ anyOtherName ++ "."
  };</code></pre><p>reason is for front end dev which solves the problem of js lack of compile time typing.</p><ul><li>jane street: the largest commercial user of ocaml in the industry by a huge margin, for those who don't know jane street is a quantitative trading firm based in nyc. they are using ocaml for everything from research tools to trading systems to systems infra to accounting systems.</li></ul><p>they have over 500 hundred ocaml programmers and over 30 million lines of ocaml. nearly a million lines of their code are open source. moreover, they've created key parts of the open-source ocaml ecosystem, like dune (community de facto build system) <a href="https://blog.janestreet.com/how-we-accidentally-built-a-better-build-system-for-ocaml-index/">tech blog discussing dune</a>; core (alternative standard library); async (cooperative concurrency library) and most recently <a href="https://blog.janestreet.com/introducing-oxcaml/">OxCaml</a> i.e fast-moving set of extensions to the ocaml language.</p><p>quoted from their blog:</p><blockquote>OxCaml is both <b>Jane Street’s production compiler</b>, as well as a <b>laboratory for experiments</b> focused towards making OCaml better for performance-oriented programming</blockquote><p>head of technology at jane street (yaron minsky) published a <a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/caml-trading-experiences-with-functional-programming-on-wall-street/02F18023B4C43BF6E53512AA7062A9A5">paper</a> about using ocaml in the financial industry, i highly recommend you to read this paper.</p><ul><li>another project is multicore ocaml, <a href="https://kcsrk.info/papers/multicore-ocaml20.pdf">technical paper</a>. now jane street has been instrumental in this area by funding research in multicore ocaml and the ocaml compiler via a research grant for the last 10+ years through the ocaml labs initiative at uni of cambridge. moreover, the tools and compiler (t&c) team at jane street actively engage with the multicore ocaml devs. <a href="https://annas-archive.org/scidb/10.1145/3192366.3192421/">another paper</a> which dives deep in the workings of multicore</li></ul><p>some other major corps that use ocaml are bloomberg, docker, cea-list, simcorp, etc. see <a href="https://ocaml.org/industrial-users/businesses">more</a>.</p><p>if this does sound interesting to you, then ask yourself what's stopping you from learning ocaml?</p></div></article>
    <div class="footer">
      Copyright © 2026 Sarthak Tomar. All rights reserved.
    </div>
  </body>
</html>
